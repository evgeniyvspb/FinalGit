![лого](logo.jpg)
# Работа с Git
## 1. Проверка наличия установленного GIT
Для проверки необходимо в терминале выполнить команду 'git version'

Если Git установлен, появиться сообщение с информацией о версии программы. Иначе будет сообщение об ошибке

## 2. Установка Git 
Загружаем последнюю версию Git с сайта git-scm.com 
устанавливаем с настройками по умолчанию

## 3. Настройка Git
При первом использовании Git необходимо представиться. Для этого  в терминале надо выполнить 2 команды:

```
git config --global user.name «Ваше имя английскими буквами»
git config --global user.email ваша почта@example.com
```

## 4. Иницициализация репозитория
Получить можно 2 способами.
1. в терминале переходим в папке, в которой хотим создать репозиторий. Выполняем команду: 
```
git init
```
2. Клонировать существующий репозиторий Git из любого места. Сделать это можно так:
```
git clone <адрес репозитория>
```

## 5. Запись изменений в репозиторий
Жизненный цыкл состояния файла выглядит так:
![цикл жизни](saverep.png)
Основной инструмент, используемый для определения, какие файлы в каком состоянии находятся — это команда:

```
git status
```
Для того чтобы начать отслеживать (добавить под версионный контроль) новый файл, используется команда 
```
git add <название файла>
git add .
```
Последняя команда используется для добавления всех файлов в текущей папке

Далее мы фиксируем все изменения, создав очередной соммит
```
git commit -m “создание коммита”    
```
Изменив аргумент на **-am** мы объединяем 2 команды, добавляя функционал **add**.

 Иногда полезно посомтреть разницу между коммитами и тут нам на помощь придёт новая команда
```
git diff
```
которая выведет построчно отличия между коммитами

## 6. Просмотр истории Commit
После того, как вы создали несколько коммитов или же клонировали репозиторий с уже существующей историей коммитов, вероятно вам понадобится возможность посмотреть что было сделано — историю коммитов. Одним из основных и наиболее мощных инструментов для этого является команда **git log.**

По умолчанию (без аргументов) git log перечисляет коммиты, сделанные в репозитории в обратном к хронологическому порядке — последние коммиты находятся вверху. 

Самый распространённый аргумент это - *-oneline* - он сокращает до минимума вывод информации, что позволяет удобно перемещаться по большим спискам

## 7. Перемещение между сохранениями
Команда __git checkout__ – переход от одного коммита к другому, позволяет перемещаться между коммитами. В дальнейшем именно это и позволит нам создавать разветвлённую сеть веток проекта. 
```
git checkout [<branch>]
```
## 8. Игнорирование файлов
Для того, чтобы исключить из отслеживания в репозитории файлы и папки, необходимо создать там файл ***.gitignore*** и записать в него их названия или шаблон, соответсвующий таким файлам и папкам.

К шаблонам в файле ***.gitignore*** применяются следующие правила:
* Пустые строки, а также строки, начинающиеся с #, игнорируются.
* Стандартные шаблоны являются глобальными и применяются рекурсивно для всего дерева каталогов.
* Чтобы избежать рекурсии используйте символ слеш (/) в начале шаблона.
* Чтобы исключить каталог добавьте слеш (/) в конец шаблона.
* Можно инвертировать шаблон, использовав восклицательный знак (!) в качестве первого символа.


## 9. Создание веток Git
Ветка в Git - это простой перемещаемый указатель на один из коммитов, обычно последний в цепочке коммитов.
По умолчанию имя основной ветки в Git - Master 
Создать ветку можно командой
```
git branch <имя новой ветки>
```
В результате создатся новый указатель на созданную ветку
Для переключения на существующую ветку выполните команду 
```
git checkout.
```

## 10. Cлияние веток и разрешение конфликтов
Слияние веток осуществляется командой **merge**. Например,
```
$ git checkout master
$ git merge hotfix
Updating f42c576..3a0874c
Fast-forward
 index.html | 2 ++
 1 file changed, 2 insertions(+)
```
Git переместил указатель ветки вперед, потому что коммит в примере, на который указывает слитая ветка hotfix, был прямым потомком другого более раннего коммита, на котором вы находились до этого. Другими словами, если коммит сливается с тем, до которого можно добраться двигаясь по истории прямо, Git упрощает слияние просто перенося указатель ветки вперед, так как нет расхождений в изменениях. Это называется «fast-forward».

Теперь ваши изменения включены в коммит, на который указывает ветка master, и исправление можно внедрять.

Иногда процесс не проходит гладко. Если вы изменили одну и ту же часть одного и того же файла по-разному в двух объединяемых ветках, Git не сможет их чисто объединить.
Git в таком случае предложит на выбор или сохранить текущую версию, или выбрать для сохранение новую, или же оставить обе в текущем проекте. Выбор всегда за Вами...

## 11. Удаление веток
Если все изменения слиты, то можно удалить ветку
```
git branch -d <название ветки>
```
Если нет слитых, то нужно выполнить слияние, а затем потворить команду выше или же принудительно удалить
